#include "Vertex.hpp"
#include "AdjacencyList.hpp"
#include <vector>
#include <utility>
#include <string>
#include <fstream>
#include <map>
#include <algorithm>
#include <unordered_map>
#include <list>

#ifndef GRAPH_H
#define GRAPH_H
using namespace std;
/* Graph struct used to certify if a graph is Series-Parallel */
using Tree_ptr = std::shared_ptr<Tree>;
struct Graph
{
    int numV; /* number of vertices in the graph */
    //Vertex* vertices; /* array of Vertex(vertices) in the graph */
    std::vector<Vertex> vertices;
    int dfsCount;    /* count of vertices visited in dfs */
    int r = -1;    /* vertex number of root node */
    Node* r_node; /* root node */
    Tree_ptr b;/*memory previous path when test k23*/
    map<int, int> relationToMain, returnToMain;
    unordered_map<int, bool>isCutPoint;
    int forcedSource = 1, forcedSink =0;
    bool addedForcedEdge = false;
    int containsForcedEdge23 = -1, containsForcedEdge4 = -1;
    vector<pair<int,int>> certPaths[6];    //the ear paths for the certificate.
    int endpoints[12];

    Graph(int numVertex) : numV(numVertex), dfsCount(0) {    /* constructor for the graph */
        //vertices=new Vertex[numV];
        vertices.resize(numVertex);
    }

    void addEdge(int w, int v);        /* function to add edges to the graph */
    bool earCompare(Tree_ptr l, Tree_ptr r); /* function to compare ears */
    void GenCS(Node* w_node, Node* v_node, Tree_ptr &seq, vector<pair<int,int>>& boundary, bool& k23found, std::map<int, Tree_ptr>&); /* depth first search, verify graph is SP or OuterPlanar */
    void update_seq(int w, Tree_ptr &seq);     /* function to combine parallel ears */
    void update_ear_of_parent(Tree_ptr f, Tree_ptr &seq_u, int w, int v, Tree_ptr &seq, int &s_, bool& k23found); /* update ear of parent edge */
    bool isValidCertificate(Tree_ptr cert);//Checks if the construction tree is valid using postOrderReduction
    void postOrderReduction(Sequence_ptr seq); //confirms the sequence - it destroys the graph in the process
    bool isValidCertificateFull(Tree_ptr cert);//Checks if the construction tree is valid using postOrderReduction
    void postOrderReductionFull(Sequence_ptr seq); //confirms the sequence - it destroys the graph in the process
    bool is_ancestor(const int child, const int ans); // check if ans is an ancestor on child
    bool compare_backedge(Sequence_ptr lhs, Sequence_ptr rhs );

    void K23Test(int t, int v, bool& balert, bool& k23found);  //tests if a k32 was found
    //verify a path the given souce s and sink t, that is in the graph G
    bool Check_Path(int s, int t, int path, int *endpoints,int flag);//checks that this path from s -> t does exist (using tree edges) and adds them to the path.
    bool Check_Path_reverse(int s, int t, int path, int *endpoints,int flag);//checks that this path from s -> t does exist (using tree edges) and adds them to the path in reverse.
    bool Check_Ear(Sequence_ptr a, int path, int *endpoints,int flag);//checks that this ear from s -> t does exist (using sequence) and adds them to the path.
    bool Check_Edge(int s, int t, int path,int *endpoints,int flag);  //checks that this edge from s -> t does exist and adds it to the path.
    bool Check_Edge_remove(int s, int t);  //checks and removes the edge if it exists
    map<int ,int> Verify_K4_Structure(int  *endpoints);        //verifies that this array of endpoings creates a k4
    map<int ,int> Verify_K23_Structure(int endpoints [12]);//verifies that this array of endpoings creates a k23
    bool Verify_Edge(int s, int t); //a function used to determine if this edge is indeed in the graph.
    void setupSourceAndSink(int source, int sink); //changes the source vertex to see the sink as the first edge in the depth first search
    bool checkTwoVertexStructure();      //checks if this graph consists of only 2 vertexes and one edge - in other words it is a bridge
    bool confirmPath(vector<pair<int,int>> &certPath, int path, int *endpoints);  //confirm the path - with the possibility of ignoring a endpoint.

    template <typename T>
    bool Check_Ear(Sequence_ptr a, int path, int *endpoints, int flag, T &vectorIterator);  //check the ear - adding the edge in through the iterator.
};

/* function to add an edge in the graph */
inline bool Graph::checkTwoVertexStructure()
{
    if (vertices[r].adjacencyList.head->next->next == vertices[r].adjacencyList.tail )
    {
        return true;
    }
    return false;

}


/* function to add an edge in the graph */
inline void Graph::addEdge(int w, int v)
{
    Node* ww = new Node();        //create an node of each
    Node* vv = new Node();
    ww->vertexNumber = w;  //set the vertex that this node represents
    vv->vertexNumber = v;
    ww->partner = vv;          //set the partner of each to be the opposite node generated by this add
    vv->partner = ww;
    vertices[w].adjacencyList.add_back(vv); //add these nodes to the appropriate lists.
    vertices[v].adjacencyList.add_back(ww);
}


/* function to setup forcing a certain first node with a possibly fake edge to ensure it has a certain source and sink. */
inline void Graph::setupSourceAndSink(int source, int sink)
{
    //find the sink from the source
    for(Node* current = vertices[source].adjacencyList.head->next;
        current != vertices[source].adjacencyList.tail;
        current = current->next)
    {
        if(sink == current->vertexNumber) {  //if we have the sink then move the links to that it is now first.
            current->prev->next = current->next;
            current->next->prev = current->prev;
            current->next = vertices[source].adjacencyList.head->next;
            current->prev = vertices[source].adjacencyList.head;
            vertices[source].adjacencyList.head->next->prev = current;
            vertices[source].adjacencyList.head->next = current;
            break;
        }
    }
}




/* function to test if construction sequence is valid */
inline bool Graph::isValidCertificate(Tree_ptr cert)
{
    //assume it is true.
    bool result = true;
    try{
        postOrderReduction(cert->root);  //try to reduce
    }
    catch (...)
    {
        result = false;  //if the reduction fails then it is false.
    }
    //if it did not fail.
    if(result == true)
    {
        for(int i = 0; i < numV; i++)
        {  //go through all of the nodes
            if(!(vertices[i].adjacencyList.isEmpty())){ //if there is anything left in the adjacency list then some edge was not represented correctly.
                result = false;
            }
        }
    }
    return result;
}

/* function to test if construction sequence is valid on a graph without a DFS performed. */
inline bool Graph::isValidCertificateFull(Tree_ptr cert)
{
    //assume it is true.
    bool result = true;
    try
    {
        postOrderReductionFull(cert->root);  //try to reduce
    }
    catch (...)
    {
        result = false;  //if the reduction fails then it is false.
    }
    //if it did not fail.
    if(result == true)
    {
        for(int i = 0; i < numV; i++){  //go through all of the nodes
            if(!(vertices[i].adjacencyList.isEmpty())){ //if there is anything left in the adjacency list then some edge was not represented correctly.
                result = false;
            }
        }
    }
    return result;
}

/* function to reduce the adjacencyLists to empty if the certificate is valid
   It removes all of these edges from the lists */
inline void Graph::postOrderReduction(Sequence_ptr seq)
{
    //cout << "deleting " << seq->s << " " << seq->t << endl;
    if(seq->comp == "PC" || seq->comp =="DC")
    {  //if it is parallel composition then try on both
        postOrderReduction(seq->l);
        postOrderReduction(seq->r);
    }
    else if(seq->comp == "SC")
    {  //if it is sequential then we want to find the middle node - the sink of the first - and split it up.  Then apply iteself to both sides.
        int midVertex = seq->l->t;
        if (midVertex != seq->r->s) throw "invalid";  //if the sink is not then the source this is wrong
        postOrderReduction(seq->l);
        postOrderReduction(seq->r);
        if(!(vertices[midVertex].adjacencyList.isEmpty()))
        {  //if the mid vertex still contains data then fail as it can't link to anything else.
            throw "invalid";
        }
    }
    else if(seq->comp == "EDGE"){  //if it is jsut an edge delete the edge nodes involved.

        delete seq->s_node;
        delete seq->t_node;
    }
}

/* function to reduce the adjacencyLists to empty if the certificate is valid
   It removes all of these edges from the lists.  The full vesrsion does it on a graph that has not had a dfs performed.*/
inline void Graph::postOrderReductionFull(Sequence_ptr seq)
{
    if(seq->comp == "PC"|| seq->comp =="DC")
    {  //if it is parallel composition then try on both
        postOrderReductionFull(seq->l);
        postOrderReductionFull(seq->r);
        if (seq->l->s != seq->r->s || seq->r->t != seq->l->t) {
            throw "invalid";  //if the sink and sources do not match
        }
    }
    else if(seq->comp == "SC")
    {  //if it is sequential then we want to find the middle node - the sink of the first - and split it up.  Then apply iteself to both sides.
        int midVertex = seq->l->t;
        if (midVertex != seq->r->s)
        {
            throw "invalid";  //if the sink is not then the source this is wrong
        }
        postOrderReductionFull(seq->l);
        postOrderReductionFull(seq->r);
        if(!(vertices[midVertex].adjacencyList.isEmpty()))
        {  //if the mid vertex still contains data then fail as it can't link to anything else.
            throw "invalid";
        }
    }
    else if(seq->comp == "EDGE")
    {  //if it is jsut an edge delete the edge nodes involved.
        if (!Check_Edge_remove(seq->s, seq->t) ) throw "invalid";

    }
}

/* function to compare ears */
inline bool Graph::earCompare(Tree_ptr l, Tree_ptr r)
{
    return vertices[l->root->t].dfsNumber < vertices[r->root->t].dfsNumber;
    /* check which sink is higher in the spanning tree */
}
inline bool Graph::is_ancestor(const int child, const int ans)
{
    auto cur = vertices[child].parent;
    while (cur != -1)
    {
        if (cur ==ans)
            return true;
        cur =  vertices[cur].parent;
    }
    return false;
}

inline bool Graph::compare_backedge(Sequence_ptr lhs, Sequence_ptr rhs )
{
    int tlhs = lhs->t;
    int trhs = rhs->t;

    if(tlhs < trhs)
        return true;
    if(tlhs == trhs && !is_ancestor(lhs->s, rhs->s))
        return true;
    if(tlhs == trhs && is_ancestor(rhs->s, lhs->s))
        return true;
    return false;

}

/* function to traverse the graph with depth first search, and verify if the graph is SP or OuterPlanar */
inline void Graph::GenCS(Node* w_node,[[maybe_unused]] Node* v_node, Tree_ptr &seq, vector<pair<int,int>>& boundary, bool& k23found, std::map<int, Tree_ptr >& cut_point_tree_map)
{
    /* Note: v_node is redundant since GenCS is always called with v_node = w_node->partner except in the first call where w_node == r_node,
       however the code first checks if w != r before it uses the value of v */

    int w = w_node->vertexNumber;    //set w to be the vertex number.
    //int v = w_node->partner->vertexNumber;  //set v to be the partners vertex number.  Remember this is through the adjacency list, so as mentioned it is the value of v__node.
    const int v = v_node?v_node->vertexNumber:-1;
    vertices[w].dfsNumber = dfsCount; /* mark w as visited by setting the dfsCount so we know the order */
    ++dfsCount;

    /* identify the parent vertex of w */
    vertices[w].parent = v; //since w was previously unvisited - it's predecessor - v - is the parent.


    int s_ = numV;    /* value to keep track of the second biggest ear */  //TOUNDERSTAND

    if(w != r)
    {  //if w is not the root - then we know we do not know the ear - as we are not finished.
        vertices[w].ear->root->clear(); /* initialize ear corresponding to parent edge of w */
        vertices[w].parentEdge = true; /* set parent edge visit to unvisited - this indicates that this parent edge is not a back edge. */
        vertices[w].balert = false; /* set boundary error alert to false */
    }

    /* process adjacency list of w */
    for(Node* u_node = vertices[w].adjacencyList.head->next; u_node != vertices[w].adjacencyList.tail; u_node = u_node->next)
    {
        int u = u_node->vertexNumber;  //get the node number.
        /* Note: w == u_node->partner->vertexNumber */
        if(vertices[u].dfsNumber == -1)
        { /* u is unvisited */
            vertices[w].numberOfChildren++; /* this vertex is a child of vertex w */
            Tree_ptr seq_u =  std::make_shared<Tree>();    /* the tree to be generated by the child */

            GenCS(u_node, u_node->partner, seq_u, boundary, k23found, cut_point_tree_map);    /* generate the child's Construction Sequence - since u_nodes partner is in the other vertex aj list*/

            update_seq(w, seq_u);            /* update the sequence of the child, combining parallel ears */
            if(w != r)
            {  //if w is not the root
                Tree_ptr a = std::make_shared<Tree>(w,u,"EDGE",u_node->partner,u_node,"TREE");  //add this edge into the tree.
                update_ear_of_parent(a, seq_u, w, v, seq, s_, k23found);
            }
            else
            {
                seq = seq_u;        /* preserve the tree when finished */
            }
        }
        else if(vertices[u].dfsNumber < vertices[w].dfsNumber) //if u has bean visited once
        {
            if(u == vertices[w].parent && vertices[w].parentEdge)
            {  //then if u is the parent of w, and w's parent is a backedge then in actually it is not.
                /* the parent edge pointing backward */
                vertices[w].parentEdge = false;
            }
            else

            { /* an outgoing back edge */
                Tree_ptr a = std::make_shared<Tree>(w, u, "EDGE",u_node->partner, u_node,"BACK");
                Tree_ptr b = std::make_shared<Tree>(w, u, "EDGE",u_node->partner, u_node,"BACK");
                update_ear_of_parent(a, b, w, v, seq, s_, k23found);
            }
        }
    }


    if(w != r)
    {  //extend the seq
        Tree_ptr a = std::make_shared<Tree>(v, w, "EDGE", w_node->partner, w_node,"TREE"); /* parent edge to be added in */
        if(s_ != numV)
        {    /* if there was a second biggest ear, add the tail to it */
            vertices[s_].stk.front().tail = seq;
            seq = a; /* assign the new sequence to be the parent edge not yet added */
        }
        else
        {
            if(v == r)
            {
                if(!isCutPoint[w])
                    seq = PC(a, seq);    /* generate the last PC operation */
                else
                {
                    seq = SC(PC(a, seq),cut_point_tree_map[w]);
                }

            }
            else
            {
                // delete(a);
                // a = new Tree(w, v, "EDGE", v_node->partner, v_node,"TREE");
                //a = new Tree(v, w, "EDGE", w_node->partner, w_node,"TREE");

                if(!isCutPoint[w])
                    seq = SC(a, seq);    /* generate the last PC operation */
                else
                {
                    seq = SC(DC(a,cut_point_tree_map[w]), seq);
                }
            }
        }

        if(!(k23found))
        {  //extend the boundry path
            if(w != r)
            {  //if not the root
                pair<int,int> a = make_pair(-1, -1);
                bool add_a=false;
                if (vertices[w].ear->root->s_node)
                {
                    int s1 = vertices[w].ear->root->s_node->vertexNumber; // get the source and sink nodes of
                    // the path.
                    int t1 = vertices[w].ear->root->t_node->vertexNumber;
                    a = make_pair(s1,t1);
                    add_a =true;
                }

                pair<int,int> b = make_pair(v,w);

                //based on the number of childeren add the pairs in correctly.
                switch(vertices[w].numberOfChildren)
                {
                    case 0:
                        if(add_a)boundary.push_back(a);
                        boundary.push_back(b);
                        break;
                    case 1:
                        if(vertices[w].ear->root->s_node->vertexNumber == w){
                            if(add_a)boundary.push_back(a);
                        }else{
                            boundary.push_back(b);
                        }
                        break;
                }
            }
        }
    }
}  //end of gencs



/* update all ears with source w */
inline void Graph::update_seq(int w, Tree_ptr &seq)
{
    StackNode top;
    /* while there are nodes on the stack */
    while(!(vertices[w].stk.empty()))
    {

        /* pop them off */
        top = vertices[w].stk.front();  //gets the node then pops it off.
        vertices[w].stk.pop_front();
        /* if the ear ends at a different spot, and not parallel, we have a K4 */
        if(seq->root->t != top.end ) {

            //we shall generate 6 path, memorize their endpoints so we can verify
            //the K4 subdivion that we have generated is actually a K4 subdivision
            //The end points has been stored into an array by the order of the path
            //Eg. p1end1, p1end2, p2end1 ,..., p6end2

            //Path #1
            //P(ear(edge)) and the the tree edges from S(P(ear(edge)) to T(P(ear(edge))
            // where edge is the parent edge of the cource of seq

            vertices[seq->root->t].ear->print_tree();

            int tmp = vertices[seq->root->t].ear->root->s;
            while(tmp != vertices[seq->root->t].ear->root->t)
            {
                tmp = vertices[tmp].parent;
            }

            endpoints[0] = top.end;
            endpoints[2] = top.end;
            endpoints[3] = seq->root->t;
            endpoints[4] = seq->root->t;
            endpoints[5] = top.sp->root->t;
            endpoints[6] = top.sp->root->t;

            //top.sp
            //path #5

            top.sp->print_tree();
            endpoints[8] = top.end;
            endpoints[9] = top.sp->root->t;

            bool trivialEar = false;

            //we need to find a ear of the child of seq->s whose sink is the parent of the top.sp->t
            //an ear between top.sp and seq.ear->t
            //path #6
            endpoints[10] = seq->root->t;
            Sequence_ptr path6= make_shared<Sequence>();//store to verify
            for(Node* current = vertices[seq->root->t].adjacencyList.head->next;
                current != vertices[seq->root->t].adjacencyList.tail;
                current = current->next)
            {
                if(vertices[current->vertexNumber].ear->root->t != vertices[seq->root->t].ear->root->t
                   && vertices[current->vertexNumber].ear->root->t != -1 )
                {
                    if(vertices[current->vertexNumber].ear->root->t != top.sp->root->t)
                    {
                        endpoints[11] = vertices[current->vertexNumber].ear->root->t;
                        endpoints[1] = vertices[current->vertexNumber].ear->root->t;
                        endpoints[7] = vertices[current->vertexNumber].ear->root->t;
                        path6 = vertices[current->vertexNumber].ear->root;//store to verify
                        break;
                    }

                }
                else if (vertices[current->vertexNumber].ear->root->t == -1)
                {
                    if(current->vertexNumber != top.sp->root->t)
                    {

                        endpoints[11] = current->vertexNumber;
                        endpoints[1] = current->vertexNumber;
                        endpoints[7] = current->vertexNumber;
                        path6 = std::make_shared<Sequence>(seq->root->t, current->vertexNumber, "EDGE");
                        trivialEar =true;
                        break;
                    }
                }

            }


            //put the endpoints int to a map where the vertex number is the key and
            //how many path terminated on corresponding vertex as value
            //if the number of distinct endpoints is not 4
            //or the number of path terminated on one endpont is not exactly 3, our certificate is wrong
            //which means the program has a bug
            map<int, int> distinct_end;
            try
            {
                distinct_end = Verify_K4_Structure (endpoints);
            }
            catch (const char* e)
            {
                cout << "The program has a bug! The output is wrong! The K4 structure is invalid." << endl;
                throw "b";
            }

            /*verify that the edges on the path are indeed edges of graph g and the
              paths are indeed vertex-disjoint except at their terminating vertices*/

            for (int k=0; k<6;k++) certPaths[k].clear();
            if(
                   //path 1
                   !Check_Path_reverse(vertices[seq->root->t].ear->root->s, endpoints[0], 1, endpoints,4)
                   ||!Check_Ear(vertices[seq->root->t].ear->root, 1, endpoints,4)
                   ||!Check_Path_reverse( endpoints[1],vertices[seq->root->t].ear->root->t, 1, endpoints,4)
                   //path 2
                   ||!Check_Path( endpoints[2],endpoints[3], 2, endpoints,4)
                   //path 3
                   ||!Check_Path( endpoints[4],endpoints[5], 3, endpoints,4)
                   //path 4
                   ||!Check_Path( endpoints[6],endpoints[7], 4, endpoints,4)
                   //path 5
                   ||!Check_Ear(top.sp->root, 5, endpoints,4)
                   //path 6 - changes depending on if it was a trivial ear.  This works due to the drop through
                   || (!trivialEar && !Check_Edge(endpoints[10], path6->s,6,endpoints,4) )
                   ||!Check_Ear(path6, 6, endpoints,4)
               )
            {
                cout << "The program has a bug! The output is wrong! The K4 structure is invalid or not in g." << endl;
            }
            throw "b";
        }

        seq = PC(seq, top.sp);            /* construct the parallel composition of all ears whose source is w */
        if(top.tail->root->s != -1)
        {            /* If there is a tail, construct the series composition */
            if(!(vertices[w].stk.empty())
               && vertices[w].stk.front().sp->root->s ==  top.sp->root->s
               && vertices[w].stk.front().sp->root->t == top.sp->root->t)
            {
                vertices[w].stk.front().tail = top.tail; /* if top is parallel to the next on the stack, preserve the tail. */
            }
            else
            {
                seq = SC(seq,top.tail); /* add the tail */
            }
        }
    }
}



/* update the back-edge associated with the parent edge of w, if necessary */
inline void Graph::update_ear_of_parent(Tree_ptr f, Tree_ptr &seq_u, int w, int v, Tree_ptr &seq, int &s_, bool& k23found)
{
    StackNode top;
    Tree_ptr currentEar;
    if(f->root->orientation == "BACK")
    {
        currentEar = f;
    }
    else
    {
        currentEar = vertices[f->root->t].ear;
    }

    /* if the ear of the parent edge is undefined, or the ear of the child edge is smaller
       than the ear of the parent edge, update the ear of the parent edge */
    if(vertices[w].ear->root->s == -1 || earCompare(currentEar, vertices[w].ear))
    {
        if(vertices[w].ear->root->s != -1) { /* ear(v, w) is defined */
            if(!(k23found) && vertices[w].ear->root->s_node->vertexNumber != w)
            {
                K23Test(w,v,vertices[w].balert, k23found);

            }
            if(seq->root->t != vertices[w].ear->root->t)
            {
                //report a k4
                for (int k =0;k<6;k++)certPaths[k].clear();
                endpoints[0] = seq_u->root->s;
                endpoints[7] = seq_u->root->s;
                endpoints[10] = seq_u->root->s;

                endpoints[3] = seq->root->t;
                endpoints[4] = seq->root->t;
                endpoints[11] = seq->root->t;

                endpoints[5] = vertices[seq->root->t].ear->root->t;
                endpoints[6] = vertices[seq->root->t].ear->root->t;
                endpoints[8] = vertices[seq->root->t].ear->root->t;

                if(seq_u->root->t != r)
                {  //root?
                    if (vertices[seq_u->root->t].ear->root->t != -1) {
                        if (!Check_Ear(vertices[seq_u->root->t].ear->root, 1, endpoints,4)) {
                            cout << "The a1 k4 subdivision could not be verified! THE PROGRAM HAS A BUG a1" << endl;
                        }

                    } else {
                        //certPaths[0].push_back(make_pair(seq_u->root->t, vertices[seq->root->t].ear->root->t) );
                    }
                }
                else
                {
                    //the source of ear(seq_u) is the root,
                    //thus we can not trace the ear by parent node
                    if (!Check_Ear(seq_u->root, 4, endpoints,4) || !Check_Path(endpoints[6],seq_u->root->t, 4, endpoints,4)) cout << "THE PROGRAM HAS A BUG 3 a1" << endl;
                }

                if (!Check_Ear(vertices[seq->root->t].ear->root, 3, endpoints,4))
                    cout << "THE PROGRAM HAS A BUG 3 a1" << endl;

                for(Node* current = vertices[seq->root->t].adjacencyList.head->next;
                    current != vertices[seq->root->t].adjacencyList.tail;
                    current = current->next)
                {
                    if(current->vertexNumber != vertices[seq->root->t].parent){
                        if(vertices[vertices[current->vertexNumber].ear->root->t].dfsNumber < vertices[w].dfsNumber && vertices[current->vertexNumber].ear->root->t != -1
                           && vertices[current->vertexNumber].ear->root->t != vertices[seq->root->t].ear->root->t)
                        {
                            //output the ear
                            endpoints[1] = vertices[current->vertexNumber].ear->root->t;
                            endpoints[2] = vertices[current->vertexNumber].ear->root->t;
                            endpoints[9] = vertices[current->vertexNumber].ear->root->t;
                            if (!Check_Path_reverse(vertices[current->vertexNumber].ear->root->s, seq->root->t, 2, endpoints,4)
                                ||!Check_Ear(vertices[current->vertexNumber].ear->root, 2, endpoints,4))
                                cout << "THE PROGRAM HAS A BUG IN IT a1" << endl;

                            //output the tree edge from curret.ear->root->s to seq_u->root->t
                            break;
                        }
                        else if(vertices[current->vertexNumber].ear->root->t == -1
                                && current->vertexNumber != vertices[seq->root->t].ear->root->t)
                        {
                            endpoints[1] = current->vertexNumber;
                            endpoints[2] = current->vertexNumber;
                            endpoints[9] = current->vertexNumber;
                            Check_Edge(endpoints[3],endpoints[2], 2, endpoints,4);

                        }
                    }
                }


                //put the endpoints int to a map where the vertex number is the key and
                //how many path terminated on corresponding vertex as value
                //if the number of distinct endpoints is not 4
                //or the number of path terminated on one endpont is not exactly 3, our certificate is wrong
                //which means the program has a bug
                map<int, int> distinct_end;
                try
                {
                    distinct_end = Verify_K4_Structure (endpoints);
                } catch (const char *e)
                {
                    cout << "The program has a bug! The output is wrong! The K4 "
                            "structure is invalid. a1"
                         << endl;
                    // K4 structure is invalid." << endl;
                    return;
                }
                if (
                        //path 1
                        !Check_Path(endpoints[0],endpoints[1], 1, endpoints,4)

                        //path 5
                        ||!Check_Path(endpoints[9],endpoints[8], 5, endpoints,4)
                        //path 6
                        ||!Check_Path(endpoints[11],endpoints[10], 6, endpoints,4)
                        //Path 4
                        ||!Check_Path(endpoints[7],endpoints[6], 4, endpoints,4)
                        //||!Check_Path_reverse( endpoints[1], vertices[endpoints[0]].ear->root->t,1, endpoints,4)

                    )
                {
                    cout << "The a1 k4 subdivision could not be verified! THE PROGRAM HAS A BUG"<<endl;
                }
                throw "a1";
            }
            else
            {
                /* add ear onto the top of the stack */
                top.end = w;    /* set the end of the ear */
                top.sp = seq;     /* update the sp tree of the ear */
                top.tail =  std::make_shared<Tree>();
                vertices[vertices[w].ear->root->t].stk.push_front(top); /* push on top of the stack */
                s_ = vertices[w].ear->root->t;
                /* reserve where the second biggest ear is, add tail */
            }

        }

        vertices[w].ear = currentEar;         /* update ear(v,w) */
        seq = seq_u;
    }
    else
    {
        bool seq_uNil = false;
        if(seq_u->root->t != currentEar->root->t)
        {
            /* if the ears have different sources we have an error */

            /*We shall generate 6 path which form a k-4 subdivision*/
            //first end-point
            endpoints[0] = seq->root->s;
            endpoints[7] = seq->root->s;
            endpoints[10] = seq->root->s;

            endpoints[1] = vertices[seq_u->root->t].ear->root->t;
            endpoints[2] = vertices[seq_u->root->t].ear->root->t;
            endpoints[9] = vertices[seq_u->root->t].ear->root->t;

            endpoints[5] = seq_u->root->t;
            endpoints[6] = seq_u->root->t;
            endpoints[8] = seq_u->root->t;

            //ear of seq and the tree edge form seq.ear->souce to sink

            // the ear in seq_u that cause the problem
            Sequence_ptr path3 =nullptr;
            for(Node* current = vertices[seq_u->root->t].adjacencyList.head->next;
                current != vertices[seq_u->root->t].adjacencyList.tail;
                current = current->next)
            {
                if(current->vertexNumber != vertices[seq_u->root->t].parent)
                {
                    if(vertices[vertices[current->vertexNumber].ear->root->t].dfsNumber < vertices[w].dfsNumber
                       && vertices[current->vertexNumber].ear->root->t != -1
                       && vertices[current->vertexNumber].ear->root->t != vertices[seq_u->root->t].ear->root->t)
                    {

                        path3 = vertices[current->vertexNumber].ear->root;
                        endpoints[3] = vertices[current->vertexNumber].ear->root->t;
                        endpoints[4] = vertices[current->vertexNumber].ear->root->t;
                        endpoints[11] = vertices[current->vertexNumber].ear->root->t;

                        //output the ear
                        vertices[current->vertexNumber].ear->print_tree();
                        //output the tree edge from curret.ear->root->s to seq_u->root->t

                        break;
                    }
                    else if (vertices[current->vertexNumber].ear->root->t == -1)
                    {  //this means that a - DFS number is smaller and it is a trivial ear
                        seq_uNil = true;
                        endpoints[3] = current->vertexNumber;
                        endpoints[4] = current->vertexNumber;
                        endpoints[11] = current->vertexNumber;

                        break;
                    }
                }
            }
            if(!path3)
                seq_uNil=true;

            //put the endpoints int to a map where the vertex number is the key and
            //how many path terminated on corresponding vertex as value
            //if the number of distinct endpoints is not 4
            //or the number of path terminated on one endpont is not exactly 3, our certificate is wrong
            //which means the program has a bug
            map<int, int> distinct_end;
            try
            {
                distinct_end = Verify_K4_Structure (endpoints);
            }
            catch (const char* e)
            {
                cout << "The program has a bug! a2 The output is wrong! The K4 structure is invalid." << endl;
                return;
            }

            /*verify that the edges on the path are indeed edges of graph g and the
              paths are indeed vertex-disjoint except at their terminating vertices*/


            for (int k=0; k<6; k++)
                certPaths[k].clear();

            if(
                   //path 1
                   !Check_Path_reverse( vertices[endpoints[0]].ear->root->s,endpoints[0], 1, endpoints,4)
                   ||!Check_Ear(vertices[endpoints[0]].ear->root, 1, endpoints,4)
                   ||!Check_Path_reverse( endpoints[1], vertices[endpoints[0]].ear->root->t,1, endpoints,4)
                   //path 2
                   ||!Check_Path( endpoints[3],endpoints[2], 2, endpoints,4)
                   //path 3
                   ||(!seq_uNil && !Check_Path_reverse( path3->s,endpoints[5], 3, endpoints,4) )
                   ||(!seq_uNil && !Check_Ear(path3, 3, endpoints,4) )
                   ||(seq_uNil && !Check_Edge(endpoints[4],endpoints[5], 3, endpoints, 4))
                   //path 4
                   ||!Check_Path( endpoints[6],endpoints[7], 4, endpoints,4)
                   //path 5
                   ||!Check_Path_reverse(vertices[endpoints[8]].ear->root->s,endpoints[8], 5, endpoints,4)
                   ||!Check_Ear(vertices[endpoints[8]].ear->root, 5, endpoints,4)
                   //path 6
                   ||!Check_Path( endpoints[10],endpoints[11], 6, endpoints,4)

               )
            {
                cout << "The program has a bug a2! The output is wrong! The K4 structure is invalid or not in g." << endl;

                return;
            }

            throw "a2";
        }
        if(currentEar->root->t == vertices[w].ear->root->t)
        {
            /* if the sinks are the same */
            if(!(k23found))
            {
                if(f->root->orientation != "BACK" && vertices[w].ear->root->s_node->vertexNumber != w){
                    K23Test(f->root->t,v,vertices[w].balert, k23found);

                }
            }
            if(seq->root->t != currentEar->root->t)
            {
                /* if the ears have different sources we have an error */

                /*We shall generate 6 path which form a k-4 subdivision*/
                int  endpoints [12];
                for(auto &vec: certPaths)
                {
                    vec.clear();
                }
                endpoints[0] = seq->root->s;
                endpoints[7] = seq->root->s;
                endpoints[10] = seq->root->s;

                endpoints[1] = seq->root->t;
                endpoints[2] = seq->root->t;
                endpoints[9] = seq->root->t;

                //ear of seq_u or seq_u
                if(seq_u->root->t != r)
                {  //root?
                    endpoints[3] = vertices[seq_u->root->t].ear->root->t;
                    endpoints[4] = vertices[seq_u->root->t].ear->root->t;
                    endpoints[11] = vertices[seq_u->root->t].ear->root->t;

                }else
                {
                    endpoints[3] = seq_u->root->t;
                    endpoints[4] = seq_u->root->t;
                    endpoints[11] = seq_u->root->t;
                }

                Sequence_ptr path5;
                bool seq5Nil = false;
                //the ear in seq->t.adjacylist that cause the problem
                for(Node* current = vertices[seq->root->t].adjacencyList.head->next;
                    current != vertices[seq->root->t].adjacencyList.tail;
                    current = current->next)
                {
                    if(current->vertexNumber != vertices[seq->root->t].parent)
                    {
                        if(vertices[current->vertexNumber].ear->root->t == -1 || ((vertices[vertices[current->vertexNumber].ear->root->t].dfsNumber < vertices[w].dfsNumber)
                                                                                  && vertices[current->vertexNumber].ear->root->t != vertices[seq->root->t].ear->root->t))
                        {

                            path5 = vertices[current->vertexNumber].ear->root;
                            if (path5->t != -1 ) {
                                endpoints[5] = vertices[current->vertexNumber].ear->root->t;
                                endpoints[6] = vertices[current->vertexNumber].ear->root->t;
                                endpoints[8] = vertices[current->vertexNumber].ear->root->t;

                            } else {
                                endpoints[5] = current->vertexNumber;
                                endpoints[6] = current->vertexNumber;
                                endpoints[8] = current->vertexNumber;
                                seq5Nil = true;
                            }
                            //output the tree edge from curret.ear->root->s to seq_u->root->t
                            //break;
                        }
                    }
                }

                //put the endpoints int to a map where the vertex number is the key and
                //how many path terminated on corresponding vertex as value
                //if the number of distinct endpoints is not 4
                //or the number of path terminated on one endpont is not exactly 3, our certificate is wrong
                //which means the program has a bug
                map<int, int> distinct_end;
                try
                {
                    distinct_end = Verify_K4_Structure (endpoints);
                }
                catch (const char* e)
                {
                    cout << " K4 structure is invalid." << endl;
                    throw "a3";
                }

                /*verify that the edges on the path are indeed edges of graph g and the
                  paths are indeed vertex-disjoint except at their terminating vertices*/

                if (!seq5Nil)
                {
                    if(
                           //path 1
                           !Check_Path(endpoints[1], endpoints[0],1, endpoints,4)
                           //path 2
                           ||!Check_Path_reverse(vertices[endpoints[2]].ear->root->s,endpoints[2], 2, endpoints,4)
                           ||!Check_Ear(vertices[endpoints[2]].ear->root, 2, endpoints,4)

                           //path 3
                           ||!Check_Path(endpoints[5], endpoints[4],3, endpoints,4)
                           //path 4
                           ||!Check_Path( endpoints[7],endpoints[6], 4, endpoints,4)
                           //path 5
                           ||!Check_Path_reverse(path5->s,endpoints[9], 5, endpoints,4)
                           ||!Check_Ear(path5, 5, endpoints,4)
                           //path 6
                           ||!Check_Ear(seq_u->root, 6, endpoints,4)
                       )
                    {
                        cout << "The program has a bug! The output is wrong! The K4 structure is invalid or not in g." << endl;
                        throw "a3";
                    }


                    if(seq_u->root->t != r)
                    { //root?

                        if(
                               //Path 2
                               !Check_Path( endpoints[3],vertices[endpoints[2]].ear->root->t, 2, endpoints,4)
                               //path6
                               ||!Check_Ear(vertices[seq_u->root->t].ear->root, 6, endpoints,4)
                           ){
                            cout << "2The program has a bug! The output is wrong! The K4 structure is invalid or not in g." << endl;

                            throw "a3";
                        }

                    }
                }
                else
                {
                    int one = 8;
                    int two = 9;
                    if (vertices[endpoints[one]].dfsNumber < vertices[endpoints[two]].dfsNumber )
                    {
                        one = 9;
                        two = 8;
                    }

                    if(    //path 1
                           !Check_Path(endpoints[1], endpoints[0],1, endpoints,4)
                           //path 2
                           ||!Check_Path_reverse(vertices[endpoints[2]].ear->root->s,endpoints[2], 2, endpoints,4)
                           ||!Check_Ear(vertices[endpoints[2]].ear->root, 2, endpoints,4)
                           //path 3
                           ||!Check_Path(endpoints[5], endpoints[4],3, endpoints,4)
                           //path 4
                           ||!Check_Path( endpoints[7],endpoints[6], 4, endpoints,4)
                           //path 5
                           ||!Check_Edge(seq->root->t, endpoints[5], 5, endpoints,4)
                           //path 6
                           ||!Check_Ear(seq_u->root, 6, endpoints,4)
                           )
                    {
                        cout << "The program has a bug! The output is wrong! The K4 structure is invalid or not in g." << endl;
                    }

                }
                throw "a3";
            }
            else
            {
                seq = PC(seq, seq_u);    /* seq and seq_u are jointed in parallel */
            }
            //TODO test this change f(vertices[w].ear->root->s_node->vertexNumber == w)
            if(vertices[w].ear->root->s_node->vertexNumber == w)
                //if (compare_backedge(currentEar->root, vertices[w].ear->root))
            {
                vertices[w].ear = currentEar;
            }
        }
        else
        {
            if(!(k23found))
            {
                if(f->root->orientation != "BACK" )
                {
                    K23Test(f->root->t,v,vertices[w].balert, k23found);
                }
            }
            if(!(vertices[currentEar->root->t].stk.empty()) &&
               vertices[currentEar->root->t].stk.front().end == w)
            {
                vertices[currentEar->root->t].stk.front().sp =
                        PC(vertices[currentEar->root->t].stk.front().sp , seq_u);
            }
            else
            {
                /* add ear onto the top of the stack */
                top.end = w;    /* set the end of the ear */
                top.sp = seq_u;    /* update the sp tree of the ear */
                top.tail = std::make_shared<Tree>();

                vertices[currentEar->root->t].stk.push_front(top); /* push onto top of the stack */

                if(s_ == numV)    /* if no second biggest, set one */
                    //s_ = f->root->t;
                    s_ = currentEar->root->t;
                else    /* if there was a second biggest ear, check if this one higher up */
                    s_ = (vertices[s_].dfsNumber < vertices[currentEar->root->t].dfsNumber) ? s_ : currentEar->root->t;
            }
        }
    }
}

inline void Graph::K23Test(int t, int v, bool& balert, bool& k23found)
{
    bool vwNil = false;  //weather or not the vw ear is a trivial ear.

    int w;

    //move up to find w
    if(vertices[t].parent == v){
        w= t;
    }else{
        int tmp = t;
        while(vertices[tmp].parent != v){
            tmp = vertices[tmp].parent;
        }
        w = tmp;
    }

    //if case 1
    if(vertices[t].ear->root->t != v)
    {
        k23found = true;
        /*We shall generate 6 path which form a k-4 subdivision*/

        endpoints[6] = w;  //one of the vertexes with three paths needed - the one on the bottom
        endpoints[8] = w;
        endpoints[10] = w;

        endpoints[5] =  v;  //the parent is always above the w - and would be below both ears.
        endpoints[11] = v;

        endpoints[0] = vertices[t].ear->root->t;  //the other one.  This needs to be the lower
        endpoints[2] = vertices[t].ear->root->t;
        endpoints[4] = vertices[t].ear->root->t;

        endpoints[3] = vertices[t].ear->root->s;  //the ear that is above the other.
        endpoints[9] = vertices[t].ear->root->s;


        //ear of t
        //the ear is vertices[t].ear->print_tree();

        //ear of v->w
        Sequence_ptr earVW = nullptr;
        int earVWt = -1;
        [[maybe_unused]] int earVWs = -1;

        //go through the other childern and choose another ear.  This ear can not be the endpoint that was already found.
        //this endpoint will be one of the two upper ones.
        for(Node* current = vertices[w].adjacencyList.head->next;
            current != vertices[w].adjacencyList.tail && current != nullptr;
            current = current->next)
        {
            if(current->vertexNumber != vertices[w].parent)
            {
                //BUG FIX continue to avoid vertices[-1] deference
                auto a =  vertices[current->vertexNumber].ear->root->t;
                if( a<0 ) continue;

                if( ( vertices[current->vertexNumber].ear->root->t != vertices[t].ear->root->t
                      || ( w != t && t != current->vertexNumber && -1 != vertices[current->vertexNumber].ear->root->t) )
                    && ( earVWt == -1 || vertices[current->vertexNumber].dfsNumber > vertices[a].dfsNumber ) )
                {  //get the min other ear
                    earVW =vertices[current->vertexNumber].ear->root;
                    endpoints[1] =  vertices[current->vertexNumber].ear->root->s;
                    endpoints[7] = endpoints[1];

                    if (endpoints[1] == -1)
                    {
                        endpoints[1] = current->vertexNumber;
                        endpoints[7] = current->vertexNumber;
                        earVWt = current->vertexNumber;
                        earVWs = current->vertexNumber;
                        vwNil = true;
                    }
                    else
                    {
                        earVWt = vertices[current->vertexNumber].ear->root->t;
                        earVWs = vertices[current->vertexNumber].ear->root->s;

                    }
                }
            }
        }


        //put the endpoints int to a map where the vertex number is the key and
        //how many path terminated on corresponding vertex as value
        //if the number of distinct endpoints is not 5
        //the end points can not be partitioned into two independent sets
        //such that one has 2 vertices with degree 3 and the other has 3 vertices with degree 2
        //which means the program has a bug
        map<int, int> distinct_end;
        try
        {
            distinct_end = Verify_K23_Structure (endpoints);
        }
        catch (const char* e)
        {
            // cout << "The program has a bug! The output is wrong! The K23 structure is invalid. a" << endl;
            return;
        }

        /*verify that the edges on the path are indeed edges of graph g and the
          paths are indeed vertex-disjoint except at their terminating vertices*/
        //if the ear is not  trivial we check the ear
        if (!vwNil)
        {
            //path1
            if(
                   //path 1
                   !Check_Ear(earVW,1, endpoints,23)
                   //path 2
                   || !Check_Ear(vertices[t].ear->root,2, endpoints,23)

                   //path 3
                   ||!Check_Path(endpoints[5], endpoints[4],3, endpoints,23)
                   //path 4
                   ||!Check_Path(endpoints[7], endpoints[6],4, endpoints,23)
                   //path 5
                   ||!Check_Path(endpoints[9], endpoints[8],5, endpoints,23)
                   //path 6
                   ||!Check_Path(endpoints[10],endpoints[11], 6, endpoints,23)

               )
            {
                cout << "The program has a bug! The output is wrong! The K23 structure is invalid or not in g. 1" << endl;

                return;
            }
            if(vertices[earVW->t].dfsNumber >= vertices[vertices[t].ear->root->t].dfsNumber)
            {
                if(!Check_Path(earVW->t, endpoints[0],1, endpoints,23))
                {
                    cout << "The program has a bug! The output is wrong! The K23 structure is invalid or not in g.b" << endl;
                    return;
                }
            }
            else
            {
                if(!Check_Path_reverse(endpoints[0], earVW->t,1, endpoints,23))
                {
                    cout << "The program has a bug! The output is wrong! The K23 structure is invalid or not in g.c" << endl;
                    return;
                }

            }

            //if the ear is trivial we just check the edge exists.
        }
        else
        {
            int one = 7, two = 0;
            if (vertices[endpoints[7]].dfsNumber >= vertices[endpoints[7]].dfsNumber)
            {  //change how the items check the two end ears beetween the two ears.  Needed since one is trivial.
                one = 0;
                two = 7;
            }
            if(
                   //path 1
                   !Check_Edge (endpoints[1],w, 1 ,endpoints,23)
                   //path 2
                   ||  !Check_Ear(vertices[t].ear->root,2, endpoints,23)

                   //path 3
                   ||!Check_Path(endpoints[5], endpoints[4],3, endpoints,23)
                   //path 4
                   ||!Check_Path(endpoints[one], endpoints[two],4, endpoints,23)
                   //path 5
                   ||!Check_Path(endpoints[9], endpoints[8],5, endpoints,23)
                   //path 6
                   ||!Check_Path(endpoints[10],endpoints[11], 6, endpoints,23)

               )
            {
                cout << "The program has a bug! The output is wrong! The K23 structure is invalid or not in g. 2" << endl;
                return;
            }

        }

    }
    else if(balert)
    {
        k23found = true;




        /*We shall generate 6 path which form a k-4 subdivision*/
        //the endpoints are set up.
        endpoints[0] = v;
        endpoints[2] = v;
        endpoints[4] = v;

        endpoints[6] = w;
        endpoints[8] = w;
        endpoints[10] = w;

        //the endpoints of the 3 ears.  One to end on another to start.
        endpoints[1] =  b->root->s;
        endpoints[7] =  b->root->s;

        endpoints[3] = t;
        endpoints[9] =t;


        endpoints[5] = vertices[w].ear->root->s;
        endpoints[11] = vertices[w].ear->root->s;

        //ear(v->w)
        //vertices[w].ear->print_tree();


        //Path b
        //b->print_tree();
        //tmp = b->root->s;

        //S(ear(f)) --> W, ear path
        //vertices[t].ear->print_tree();
        if(vertices[vertices[w].ear->root->t].dfsNumber >= vertices[vertices[t].ear->root->t].dfsNumber)
        {

            //put the endpoints int to a map where the vertex number is the key and
            //how many path terminated on corresponding vertex as value
            //if the number of distinct endpoints is not 5
            //the end points can not be partitioned into two independent sets
            //such that one has 2 vertices with degree 3 and the other has 3 vertices with degree 2
            //which means the program has a bug
            map<int, int> distinct_end;
            try
            {
                distinct_end = Verify_K23_Structure (endpoints);
            }
            catch (const char* e)
            {
                cout << "The program has a bug! The output is wrong! The K23 structure is invalid." << endl;
                return;
            }

            /*verify that the edges on the path are indeed edges of graph g and the
              paths are indeed vertex-disjoint except at their terminating vertices*/
            if(
                   //path 1
                   !Check_Ear(b->root, 1, endpoints,23)
                   //path 2
                   ||!Check_Ear(vertices[w].ear->root, 2, endpoints,23)
                   ||!Check_Path(v,vertices[w].ear->root->t, 2, endpoints,23)
                   //path 3
                   ||!Check_Path_reverse(vertices[t].ear->root->s,t, 3, endpoints,23)
                   ||!Check_Ear(vertices[t].ear->root, 3, endpoints,23)
                   //path 4
                   ||!Check_Path(endpoints[7], endpoints[6],4, endpoints,23)
                   //path 5
                   ||!Check_Path(endpoints[9],endpoints[8], 5, endpoints,23)
                   //path 6
                   ||!Check_Path(endpoints[11],endpoints[10], 6, endpoints,23)

               )
            {
                cout << "The program has a bug! The output is wrong! The K23 structure is invalid or not in g." << endl;
                return;
            }
        }
        else
        {
            balert = true;
            b = vertices[t].ear;
        }
    }
}



//confirms a path exists using tree edges.  This means that t must be above in the tree.
inline bool Graph::Check_Path(int s, int t, int path, int *endpoints, int flag)
{
    int tmp = s;
    while(tmp != t && tmp>-1)
    {   //move up the tree until we found the edge.  If we come across an edge that does not exists then fail the check.
        //also end the loop if we found the correct edge.  We currently check the parent - then move up.  If the parent is the target we finish.

        if(!Check_Edge(tmp, vertices[tmp].parent, path, endpoints,flag))
            return false;

        tmp = vertices[tmp].parent;
    }
    return true;
}

inline bool Graph::Check_Path_reverse(int s, int t, int path, int *endpoints,int flag)
{
    int tmp = s;
    if (s<0)
        return false;
    if(s != t)
    {   //move up the tree until we found the edge.  If we come across an edge that does not exists then fail the check.
        //also end the loop if we found the correct edge.  We currently check the parent - then move up.  If the parent is the target we finish.

        if (!Check_Path_reverse(vertices[tmp].parent, t, path, endpoints,flag) )
            return false;
        if(! Check_Edge(vertices[tmp].parent, tmp, path,endpoints,flag))
            return false;

    }
    return true;
}

inline bool Graph::confirmPath(vector<pair<int,int>>& certPath, int path, int *endpoints)
{
    int current = certPath.front().first;

    for (unsigned i=0; i<certPath.size() ; i++)
        if( Check_Edge(certPath[i].first, certPath[i].second, path,endpoints,4) && current == certPath[i].first   )
        {  //ensure that this edge exists - and that it is the next in the series.
            current = certPath[i].second; //move the series checker up.
        } else {
            return false;     //confirm the path - we use 4 just as a test.
        }
    return true;
}


//we want to check an ear.  The vectorIterator is templated so we do not need to know the complex C++ class involved.
//the version with the iterator adds the path where the iterator is in an existing path
template <typename T>
bool Graph::Check_Ear(Sequence_ptr a, int path, int *endpoints, int flag, T &vectorIterator)
{
    if (!a)
        return false;
    Sequence_ptr leaf = a;
    if(leaf->l == nullptr)
    {    /* if no children, verify self */
        if(!Check_Edge(leaf->s,leaf->t, path, endpoints,flag))
        {  //if the edge does not exists
            return false;
        }
        else
        {  //if it does then add the pair to the path
            pair<int,int> k = make_pair(leaf->s, leaf->t);
            vectorIterator.push_back(k);
            return true;
        }
    }
    else
    {
        //if it is not a child recursively check its children
        if (leaf->comp == "SC")
        {
            return Check_Ear(leaf->l,path, endpoints,flag, vectorIterator)
                    ||Check_Ear(leaf->r,path, endpoints,flag, vectorIterator);  //we just need one of the parallel ears.
        }
        else /*if(leaf->comp == "PC")*/
        {
            return Check_Ear(leaf->r,path, endpoints,flag, vectorIterator);  //since they are parallel only do the left.
        }

    }
}


//this is the same logic as above however it adds the edge like normal
inline bool Graph::Check_Ear(Sequence_ptr a, int path, int *endpoints, const int flag)
{
    if (!a)
        return false;
    Sequence_ptr leaf = a;
    if(leaf->l == nullptr){    /* if no children, verify self */
        if(!Check_Edge(leaf->s,leaf->t, path, endpoints,flag))
        {
            return false;
        }
        else
        {
            return true;
        }
    }
    else
    {
        if (leaf->comp == "SC")
        {
            auto left_b = Check_Ear(leaf->l,path, endpoints,flag);
            auto right_b =Check_Ear(leaf->r,path, endpoints,flag);
            return left_b || right_b;
        }
        else /* if(leaf->comp == "PC") */
        {
            return Check_Ear(leaf->l,path, endpoints,flag);  //since they are parallel only do the left.
        }
    }
}


//check that this edge exists and if so add it to the path specified.
//also confirm the endpoints condition and distinctiveness of the vertexes.
inline bool Graph::Check_Edge(int s, int t, int path,int *endpoints,int flag)
{
    if (s<0 || t <0)
        return false;
    //run through all of the adjacent vertexes of s.
    for(Node* current = vertices[s].adjacencyList.head->next;
        current!=nullptr && current != vertices[s].adjacencyList.tail;
        current = current->next)
    {

        if(t == current->vertexNumber)
        {//this edge is actually in graph g
            //we now need to check whether there are common vertices other than the endpoints
            if(flag == 4)
            {  //if we are dealing with a k4 graph
                if(vertices[s].k4visit != 0 && vertices[s].k4visit != path)
                { //if we have not yet visited this vertex (not 0) and if we have then it is in this path.
                    //this is a failure conidition - unless we are dealing with an endpoint.
                    int *p;
                    p = find(endpoints, endpoints+12, s);  //find where it is

                    if(p == endpoints+12) {
                        return false;
                    }                        //if we are past all endpoints with p then it does not exist in endpoints.
                }

                //same idea - but if t is already visited then it is always a fail.
                if(vertices[t].k4visit != 0 && vertices[t].k4visit != path)
                {
                    int *p;
                    p = find(endpoints, endpoints+12, t);
                    if(p == endpoints+12){ return false;
                    }
                }


                //mark the vertice source as visited. This is to ensure that it is disjointed - but we can still move off of the target.
                if(vertices[s].k4visit == 0)
                    vertices[s].k4visit = path;

                if (r != -1)
                    certPaths[path - 1].push_back( make_pair(s,t) ); //add the edge to the appropriate path.
                if ( (s == forcedSink && r == t) || (t == forcedSink && r == s) )
                    containsForcedEdge4 = path - 1;
                return true;
            }
            else if(flag == 23)
            {  //if we are dealing with a k23 graph
                //same as the check for k4 on source - just 23 instead
                if(vertices[s].k23visit != 0 && vertices[s].k23visit != path)
                {
                    int *p;
                    p = find(endpoints, endpoints+12, s);
                    if(p == endpoints+12) {
                        return false;
                    }
                }

                //same thing but for t.
                if(vertices[t].k23visit != 0 && vertices[t].k23visit != path){
                    int *p;
                    p = find(endpoints, endpoints+12, t);
                    if(p == endpoints+12)  {
                        return false;
                    }
                }

                if(vertices[s].k23visit == 0)
                    vertices[s].k23visit = path;


                if (r != -1)
                    certPaths[path - 1] .push_back( make_pair(s,t) );
                if ((s == forcedSink && r == t) || (t == forcedSink && r == s) )
                    containsForcedEdge23 = path - 1;

                return true;


            }
            else
            {  //if it is netiher k23 of k4 this is a problem
                cout << "Warning, wrong flag when checking negative certificate!" <<endl;
                return false;
            }
            //if this edge was forced then mark it as so.



        }
    }
    // if the loop halts at the end, which means edge{s, t} is not in graph g
    return false;
}


//check that this edge exists and if so add it to the path specified.
//also confirm the endpoints condition and distinctiveness of the vertexes.
inline bool Graph::Check_Edge_remove(int s, int t)
{
    //run through all of the adjacent vertexes of s.
    for(Node* current = vertices[s].adjacencyList.head->next; current != vertices[s].adjacencyList.tail;current = current->next)
    {

        if(t == current->vertexNumber){//this edge is actually in graph g
            //we now need to check whether there are common vertices other than the endpoints

            delete current->partner;
            delete current;
            return true;
        }
    }
    //if the loop halts at the end, which means edge{s, t} is not in graph g
    return false;
}




inline map<int ,int> Graph::Verify_K4_Structure(int endpoints [12])
{


    //put the endpoints int to a map where the vertex number is the key and
    //how many path terminated on corresponding vertex as value
    map<int, int> distinct_end;


    //run through all endpoing
    for (int i= 0; i < 12; i++ )
    {
        int a = endpoints[i];
        if( distinct_end.find(a) != distinct_end.end() ){  //if it is already in the map then increment
            distinct_end[a] = distinct_end[a] + 1;
        }else{ //otherwise add it
            distinct_end.insert( make_pair(a, 1));
        }

    }

    //check that there are exact 4 distinct endpoints
    if(distinct_end.size() != 4 )
    {

        cout<< "more than 4 vertices"<< std::endl;
        throw "e";

        return distinct_end;
    }

    //check each endpoint it the common terminating vertex of 3 paths
    for(const auto iter :  distinct_end)
    {
        if(iter.second != 3){
            cout << 3 << endl;
            throw "e";
            return distinct_end;

        }
    }

    return distinct_end;
}


inline map<int ,int> Graph::Verify_K23_Structure(int endpoints [12])
{


    //put the endpoints int to a map where the vertex number is the key and
    //how many path terminated on corresponding vertex as value
    map<int, int> distinct_end;

    //run through the end points.
    for (int i= 0; i < 12; i++ )
    {
        int a = endpoints[i];
        if( distinct_end.find(a) != distinct_end.end() ){ //if it is in the map already increment.
            distinct_end[a] = distinct_end[a] +1;
        }else{  //if it is not in the map add it
            distinct_end.insert( make_pair(a ,1));

        }
    }

    //check that there are exact 5 distinct endpoints
    if(distinct_end.size() != 5 )
    {
        cout << "FAIL3 on "<< distinct_end.size() << endl;
        throw "e";
        return distinct_end;
    }

    //check each endpoint it the common terminating vertex of 3 paths
    int degree2 = 0;
    int degree3 = 0;

    //store the endpoints to verify the k-23 by check the indepent set
    //we need to check that we have the correct number of degree 2s and degree 3s
    vector< int > x, y;
    for(const auto iter :  distinct_end)
    {
        if(iter.second == 3)
        {
            degree3++;
            x.push_back(iter.first);
        }
        else if(iter.second == 2)
        {
            degree2++;
            y.push_back(iter.first);
        }
        else
        {
            cout << "FAIL1"<<endl;
            throw "e";
            return distinct_end;
        }
    }

    if(degree2 !=3 || degree3 != 2)
    {
        cout << "FAIL2"<<endl;
        throw "e";
        return distinct_end;
    }

    return distinct_end;
}

//a function used to determine if this edge is indeed in the graph.
inline bool Graph::Verify_Edge(int s, int t)
{
    for(Node* current = vertices[s].adjacencyList.head->next;   //run through all available edges
        current != vertices[s].adjacencyList.tail;
        current = current->next)
    {

        if(t == current->vertexNumber) return true; //if this one is correct return
    }

    return false;  //since none is left return false
}
#endif
